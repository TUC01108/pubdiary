{% extends 'layout.html' %}
<!-- Copy and paste this for each new day and update date/activities (update month)
	<h2>00/08/20</h2>
	<h3>Morning:</h3> 
	<p>
	</p>	
	<h3>Afternoon:</h3>
	<p>
	</p>			
	<h3>Evening:</h3>
	<p>
	</p>

	For links - >  <a href="hello.html">Click Here!</a>
-->
{% block content %}
<div id="Diary">
This is the <span class="name">Diary</span> section of my web page.
</div>
<!-- POST Diary entries below -->

<h2>08/08/20</h2>
	<h3>Morning:</h3> 
	<p>8:29AM Olava asleep on my chest. Finished the pset5 submission yesterday with a classmate's help, but it still has some bugs that I need to iron out.<br>
		Going to start again with wiki pset2 for web50.<br>
		Something I want to improve on is strategizing before writing a line of code. I don't want to paralyze myself from getting started, but often I run into roadblocks that I may be able to see if I pause beforehand.<br>
		To do this I will write a script of beginning, middle, and end, much like I did in film school and when problems arise I pause, take a breath, see where I am and think of the best next step. It can be backwards if necessary, but always think about the possible steps forward.<br>
		So for this project I am replicating a wikipedia website model using github's markdown language.<br>
		SPECIFICATIONS:<br>
		---------------------<br>
		Entry Page- When visiting /wiki/TITLE where TITLE is the title of an encyclopedia article will take me to that page by calling the util function. If the page does not exist an error page will appear. The title of the page should include the name of the entry.<br>
		Index Page- Clicking on any entry name will take you to that page.<br>
		Search- If the query matches the name then user is taken to that entry's page. If the query does not match any name then user is taken to a search results page that shows a list of all entries that have the query as a substring. Clicking on any entries on the search results page will take you to the entry's page.<br>
		New Page- Clicking "Create New Page" takes the user to a page where they can create a new entry. Should be able to enter a title and in a textarea should be able to enter Markdown content for the page. User's then click a button to save their entry. When saved if the entry title already exists then an error will appear. Otherwise it's saved and the user is taken to the new page.<br>
		Edit Page- On each entry's page there should be a link to take the user to a page where they can edit the markdown content for that page. The textarea should be prepopulated with existing content. The user should be able to save. Then redirected back to that entry's page.<br>
		Random Page- Clicking "Random Page" should take user to a random wiki entry.<br>
		Markdown to HTML Conversion- On each entryâ€™s page, any Markdown content in the entry file should be converted to HTML before being displayed to the user. You may use the python-markdown2 package to perform this conversion, installable via pip3 install markdown2.<br>
		
	</p>
	<h3>Afternoon:</h3>
	<p>
	</p>			
	<h3>Evening:</h3>
	<p>
	</p>

<h2>07/08/20</h2>
	<h3>Morning:</h3> 
	<p>8:05AM Back at it. Can I look from macro for a minute to see what I'm actually doing and what the small parts are to do each of the things that need to get done? Less technical, more owner.<br>
		Doing a check50 real quick to see what it says.<br>
		Now I'm back in a forever loop of watching the tutorial video. I need to formulate a question to the group. Put into words what I am struggling with and someone may be able to help.<br>
		I asked the slack group for help. Let's see what they can find. It's becoming difficult seeing what I am doing.<br>
		9:24AM Taking a step back now and going to write out what's going on.<br>
		So right now I have a program that accepts the input at command line of:<br>
		./speller [dictionary] text<br>
		this can also omit the dictionary, which will default it to "dictionaries/large"<br>
		The only other option being "dictionaries/small", which is for debugging purposes. Faster to see what is going on. Also for checking memory leaks.<br>
		So we have a dictionary file being "pointed to" and a text file being "pointed to". Now what do we do with those 2 texts?<br>
		With the dictionary we LOAD it. This is our first function.<br>
		The goal of ALL of this is to: implement the fastest spell checker you can!<br>
		With the load function we ---<br>
		Lost my train of thought as coffee rush had me emailing my dad... focus!<br>
		So at the top of dictionary.c is a node struct called node. In this node is a char word and a pointer to the *next node struct.<br>
		This is my linked list.<br>
		Something that I was wondering is if the head of my linked list is the first node being pointed to from the hash table array defined below this?<br>
		The other possibility is that the hash table[ith] is the head that is pointing to the next node in the linked list?<br>
		Still havent ironed this out and maybe that's where I'm missing information that I need<br>
		Anyway so as I mentioned then a global pointer array titled table is declared, which represents the hash table that points to the nodes.<br>
		The array contains N node pointers. So this makes me think it's just a pointer to the linked list. Let's go with that<br>
		They had set N to 1 as a default bucket amount, we are supposed to find an optimal value. The more buckets there are, the quicker our sort can become as we edge towards big O of 1.<br>
		I will figure out what value N should be.<br>
		Load, hash, check, size, unload have not been fully implemented for us. That's our job.<br>
		I need to understand speller.c just enough to know what I am doing with the functions in dictionary.c<br>
		I think I have enough understanding. The confusing stuff is basically calculating the time it takes to do each function so that at the end of the program it spits out how long each and all of them together took to spell check.<br>
		The rest is going word by word and checking the text file to the dictionary file.<br>
		They give us options for using our spell checker with preloaded texts. Seeing how the staffs implementation works. Also we can compare our spell checker with the staff's or use the preloaded keys to do a quicker check.<br>
		-------------------<br>
		SPECIFICATIONS:<br>
		NO ALTERING speller.c or Makefile<br>
		ALTER dictionary.c, but not the declarations of each function.<br>
		May add local or global variables to dictionary.c<br>
		May change the value of N.<br>
		May alter dictionary.h, but not the declarations of each function.<br>
		Check() must be case-insensitive.<br>
		Check() should only return true if the word is actually in the dictionary.<br>
		Spell checker may only take text, and optionally, dictionary as input.<br>
		Spell checker must not leak memory.<br>
		You may use hash functions from online as long as you cite the source.<br>
		---------<br>
		Okay now the diary is PUBLIC! Hopefully I did this right.<br>
		Back to the project<br>
		So how is my hash function working right now?<br>
		So remember we have decide that node *table[N] is the array of basically vertical structure that will have linked list nodes being pointed to one at a time. Chaining from it.<br>
		To do this do we need to create a new pointer at each value of table[?] as we go? Does it work if we just use {table[hashed] = p1} as we have been and then mallocing a new value each time we get to a new word?<br>
		Does this even work?<br>
		I'm going to walk through my load function piece by piece.<br>
		bool load(const char *dictionary) is a function that returns either true or false: if the dictionary was loaded successfully.<br>
		It starts with one parameter which is const char *dictionary: the string of the whole dictionary file.<br>
		Then I initialize FILE *fp: A pointer of type FILE that I will point to the data read in fopen.<br>
		char word1[LENGTH]: is a word with a maximum length of LENGTH aka 46.<br>
		wordCount = 0; is the count of words starting at 0.<br>
		node *p1; is of the node struct to be used for each new word we are adding to hash table.<br>
		*table = NULL; probably isn't necessary to put here, but making sure that the array points to NULL to start.<br>
		Now I start with an if statement that compares the string dictionary input with either dictionaries/large or dictionaries/small. Then I check if opening either gives a non NULL value. If it does then we continue. If not then it closes fp and returns false.<br>
		Now I start a while loop to fscanf() each word one at a time until we read EOF.<br>
		For each word I malloc(sizeof(node)) for p1: This creates a node's worth of space in memory for p1.<br>
		I check to make sure p1 is not NULL.<br>
		I copy word1 into the word value in p1.<br>
		I set the value of next in p1 to NULL<br>
		I hash the word using the hash() function.<br>
		If table[hashed] == NULL : this means that if the value that table[hash value of word] is NULL then.<br>
		table[hashed] = p1; This means the table[hash value of word] points to the p1 node we created.<br>
		wordCount++; Increase the wordCount by 1.<br>
		free(p1); free the value at node p1 to prepare for next malloc of node.<br>
		Check to see if wordCount has reached the large dictionary value or the small dictionary value. NEED TO FIX THIS.<br>
	</p>	
	<h3>Afternoon:</h3>
	<p>
	</p>			
	<h3>Evening:</h3>
	<p>
	</p>

<h2>06/08/20</h2>
	<h3>Morning:</h3> 
	<p>10:19AM I want to make a public diary version of this so people can see what I'm saying and doing if they are interested. Most of what I share is okay to be out there.<br>
		Will think about this more when I finish this pset5. Also I will pick something I write in here and post to twitter to provide that with content.<br>
		Getting a job in today's world is easier if people think they know more about you than they do.<br>

	</p>	
	<h3>Afternoon:</h3>
	<p>12:35PM Haven't been updating here enough, but at the moment I have the "large" and "small" dictionaries going line by line through their files and now have to strcpy that information into a hashtable. I think that's what I have to do.<br>
		So at the moment I am reading about malloc.. is this stalling?<br>
		Within the program I need to allocate a node's worth of memory for each node I create.<br>
		Just got to the part where it reminded me to check for null always after running malloc.<br>
		Now I'm a little caught up with figuring out how to define the typedef struct node jibberish. Figuring this out.<br>
		2:15PM I'm close to getting this load function. I have the node strcpy word and then I have it copying into table, but I need the table to point to the word and then the word to point to the first item in the index of table.<br>
		Think I got this... Will see.
	</p>			
	<h3>Evening:</h3>
	<p>7:45PM I'm still at this... feel a bit closer, but not making strides as I hoped I would by now.<br>
		It's kicking my butt, but I got this.<br>

	</p>

<h2>05/08/20</h2>
	<h3>Morning:</h3> 
	<p>7AM Up and at em. Going to give this a crack before Yordana and Olava awake.<br>
		11:23AM I have a few minutes to work on this. Let's see what I can do.<br>

	</p>	
	<h3>Afternoon:</h3>
	<p>
	</p>			
	<h3>Evening:</h3>
	<p>6:11PM Today is going too fast. I'm back in and getting it right now.<br>
		Watching the video again to see if I missed something. I'm not correctly loading the dictionary in, so nothing else matters until I fix this.<br>
		7:34PM Breakthrough! Well not really, but I can read from the dictionaries now! Using fopen()... only took a few days, anyways this is great.<br>
		I can now store each word in a hash table. SOMEHOW.<br>
		I'm leaving off here. Feeling good. On to fscanf next and node stuff.<br>
	</p>

<h2>04/08/20</h2>
<h3>Morning:</h3> 
<p>11:21AM I'm working on PSET5 for Rodrigo's coding school. I'm almost a real coder.<br>
	I want to do a live diary entry as I go. So here it is.<br>
	So I have a few resources to look at for hash function examples. <br>
	I don't fully know how to do it using the methods they talk about, but I figure I have an idea how to get started. <br>
	Basically we are creating an array of pointers that acts as the head of our hash table and there are [N] amount of these buckets.<br>
	The hash function is what changes the string aka dictionary word from a word to a number 0 -> [N] that can be == to the index of the array of pointers.<br>
	With this new value for the word we can point from the head of that array to a node and begin a linked list.<br>
	The goal is to not have too many words in each "bucket" as that will slow down the hash table and bring us closer to O(n) instead of O(1). We WANT constant time.<br>
	Let's get started and brush up on the information they provide to us, so I'm not over stepping anything that's given. <br>

</p>	
<h3>Afternoon:</h3>
<p>12:07PM Getting a bit caught up with how much I have too do with the hash function.<br>
	I have a feeling it's less than I think. Basically a lowercase 'a' in ascii == 01100001 and 'z' == 01111010 so this can be the buckets.<br>
	The question becomes how to deal with the second letter, third letter and so on? But for a first version I can deal with just the first letter and my hash function wil rather simply just turn a first letter of word from char to binary.<br>
	I'm not sure how to do this in c so I'll google it.<br>
	Looks like I'll just be using a function to mod each place in the original integer and divide by 10 to move to the next value.<br>
	So I got the code to work and it stores the binary in an array. I'm wondering if this will be a problem because I need to recognize this as an integer. I think.<br>
	Either way it will work. This may just add some unnecessary for loops for checking if 1 array equals another array.<br>
	But now that I think about it. It may make more sense to have the buckets sitting as an integer and have a way to convert word's first letter from ascii to binary to that integer. That's what the hash function will do.<br>
	And I think I just restated something I said an hour ago, but it makes more sense in my mind now. 12:41pm.<br>
	12:58PM Okay I have the function made that takes first letter of string and turns it into binary. "A hash function"<br>
	1:24PM Okay I've finished this has function so that it accepts an input. I will take a break and see where I go next.<br>
	1:42PM I'm back after some eggs and chicharron.<br>
	I have a hash function now to place it in the load function. I'm just now realizing do I even need to do any binary conversion??<br>
	Do I just cast it with (int)(*(word))?<br>
	I'm watching video that helps give idea about what to do. Looks like as I'm reading through characters of dictionary I need to go one character at a time and when I get to end of word (\0) I hash that word to find it's index and then I store that word in a node at that index.<br>
	I'm currently looking for a resource that Rodrigo shared with us that shows how to find end of word using linked list I believe? Could be wrong. Either way I need to organize useful material better to find so I'm not wasting time like this.<br>
	I'm looking at a program labeled "getwords.c" that I believe has what I need.<br>
	2:46PM I feel like I just did a bunch of mush copy and paste from the new stuff I just found and the old stuff I had sitting in there.<br>
	Not feeling great about that, but feel better than where I was.<br>
	I need to take a break : /<br>

</p>			
<h3>Evening:</h3>
<p>7:40PM Been working on it for a few after dinner. Nothing is coming to me yet. I'll give it another crack tomorrow. Let the brain figure it out in sleep.<br>
	
</p>

<br></br>
</div>

<hr>
<div id="Rules">
<p><h2>Rules</h2> 
<ol>
	<li>	Print upon completion of every 7 days</li>
	<li>	Find ways to improve clarity and reduce wasteful living</li>
	<li>	Always remember to do what helps the most people, as that will provide a proportional amount of success</li>
</ol>
</p>
</div>
<hr>
<h2>Bottom</h2>
<div id="Bottom">
This is the <span class="name">Bottom</span> section of my web page.
</div>

</p>
{% endblock %}


